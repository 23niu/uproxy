<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Sctp Multi-Datachannel tester</title>
<style>
/* button {
  font: 12px sans-serif;
  padding: 5px;
} */
textarea {
  font-family: monospace;
}
#logDiv {
  font-family: monospace;
  white-space: pre;
}
</style>
</head>
<body>
  Open the JS console, then here's some things to type to play with  SimpleDataPeer which wraps PeerConnection's data channels into a simpler Connection data channels...
  <div id="logDiv">
  var peerA, peerB;

  peerA = new DataPeer({debug: true, debugPeerName: "peerAlice"});
  peerB = new DataPeer({debug: true, debugPeerName: "peerBob"});

  peerA.setSendSignalMessage(peerB.handleSignalMessage.bind(peerB));
  peerB.setSendSignalMessage(peerA.handleSignalMessage.bind(peerA));

  peerA.newDataChannel("a");
  peerB.send("e","hello");
  peerA.send("b","hello on b from a");
  /* setTimeout(function() {
      peerA.newDataChannel("c");
      peerB.send("b", "after 1/2 second on b from b");
  }, 500);

  setTimeout(function() {
      peerA.send("a", "after 1 second on a from a");
      peerA.send("c", "after 1 second on c from a");
  }, 1000);
  */
  </div>
<!-- END OF HTML -->

<script>
'strict';

// Generic use of RTCPeerConnection as the name for WebRTC's peer connection
var RTCPeerConnection = RTCPeerConnection || webkitRTCPeerConnection || mozRTCPeerConnection;

// Top level variables to play with in the console.
var peer1, peer2;

window.onload = function () {

  peerA = new DataPeer({debug: true, debugPeerName: "peerA"});
  peerB = new DataPeer({debug: true, debugPeerName: "peerB"});

  peerA.setSendSignalMessage(peerB.handleSignalMessage.bind(peerB));
  peerB.setSendSignalMessage(peerA.handleSignalMessage.bind(peerA));

  var arr = new Uint8Array((2 << 18) - 1000);
  peerA.send("a",arr);

  // peerA.newDataChannel("a");
  // peerA.newDataChannel("b");

  //setTimeout(function() {
  //    peerA.newDataChannel("c");
  //    peerB.send("b","hello on b? after 1/2 second");
  //}, 500);

/*
  setTimeout(function() {
      peerA.send("a", "after 1 second on a");
      peerA.send("c", "after 1 second on c");
  }, 1000);

  setTimeout(function() {
    peerA.close();
    peerB.close();
  }, 1500);
*/
}


//-----------------------------------------------------------------------------
// Console debugging utilities
//-----------------------------------------------------------------------------
// Abbreviation for console['type'] (type = log/warn/error) that inserts time at
// front.
function trace_to_console(type) {
  var argsArray = [];
  for (var i = 1; i < arguments.length; i++) {
    argsArray[i - 1] = arguments[i];
  }
  var text = argsArray[0];
  var s = (performance.now() / 1000).toFixed(3) + ": " + text;
  argsArray[0] = s;
  console[type].apply(console, argsArray);
}
var trace = {
  log: trace_to_console.bind(null, "log"),
  warn: trace_to_console.bind(null, "warn"),
  error: trace_to_console.bind(null, "error"),
};

//-----------------------------------------------------------------------------
// A class that wraps a peer connection and its data channels.
//-----------------------------------------------------------------------------
// TODO: check that Handling of pranswer is treated appropriately.
var SimpleDataPeerState = {
  DISCONNECTED: 'DISCONNECTED',
  CONNECTING: 'CONNECTING',
  CONNECTED: 'CONNECTED'
};

function SimpleDataPeer(options) {
  if (options) {
    this._debugPeerName = options.debugPeerName;
    this._debug = options.debug;
  }
  // A way to speak to the peer to send SDP headers etc.
  this._sendSignalMessage = null;
  // The peer connection.
  this.pc = new RTCPeerConnection(null,
      {optional: [{DtlsSrtpKeyAgreement: true}]});

  // This state variable is used to fake offer/answer when they are wrongly
  // requested and we really just need to reuse what we already have.
  this.pcState = SimpleDataPeerState.DISCONNECTED;

  // Add basic event handlers.
  this.pc.addEventListener("icecandidate",
      this._onIceCallback.bind(this));
  this.pc.addEventListener("datachannel",
      this._onDataChannel.bind(this));
  this.pc.addEventListener("negotiationneeded",
      this._onNegotiationNeeded.bind(this));
  this.pc.addEventListener("signalingstatechange",
      this._onSignalingStateChange.bind(this));
  /* // Another way.
  this.pc.onicecandidate = this._onIceCallback.bind(this);
  this.pc.ondatachannel = this._onDataChannel.bind(this);
  this.pc.onnegotiationneeded = this._onNegotiationNeeded.bind(this);
  this.pc.onsignalingstatechange = this._onSignalingStateChange.bind(this);
  */

  // Start off with no open data channels.
  this.channels = {};
}

SimpleDataPeer.prototype.setSendSignalMessage = function (sendSignalMessageFn) {
  this._sendSignalMessage = sendSignalMessageFn;
}

// Handle a message send on the signalling channel to this peer.
SimpleDataPeer.prototype.handleSignalMessage = function (messageText) {
  trace.log(this._debugPeerName + ": " + "handleSignalMessage: \n" +
      messageText);
  var json = JSON.parse(messageText);
  // TODO: If we are offering and they are also offerring at the same time,
  // pick the one who has the lower randomId?
  // (this.pc.signalingState == "have-local-offer" && json.sdp &&
  //    json.sdp.type == "offer" && json.sdp.randomId < this.localRandomId)
  if (json.sdp) {
    // Set the remote description.
    this.pc.setRemoteDescription(
      new RTCSessionDescription(json.sdp),
      // Success
      function () {
        trace.log(this._debugPeerName + ": " +
          "setRemoteDescription sucess:", this.pc.remoteDescription);
        if (this.pc.remoteDescription.type == "offer") {
          this.pc.createAnswer(this._onDescription.bind(this));
        }
      }.bind(this),
      // Failure
      function (e) {
        trace.error(this._debugPeerName + ": " +
          "setRemoteDescription failed:", e);
      }.bind(this));
  } else if (json.candidate) {
    // Add remote ice candidate.
    this.pc.addIceCandidate(new RTCIceCandidate(json.candidate));
  } else {
    trace.warn(this._debugPeerName + ": " +
        "handleSignalMessage got unexpected message: ", message);
  }
}

// Connect to the peer by the signalling channel.
SimpleDataPeer.prototype.negotiateConnection = function () {
  this.pcState = SimpleDataPeerState.CONNECTING;
  this.pc.createOffer(
    this._onDescription.bind(this),
    function(e) {
      trace.error(this._debugPeerName + ": " +
        "createOffer failed: ", e.toString());
      this.pcState = SimpleDataPeerState.DISCONNECTED;
    }.bind(this)
    );
}

// Create a new data channel.
SimpleDataPeer.prototype.newDataChannel = function (channelId, options) {
  // if no channel id is specified, fail.
  if (!channelId) {
    trace.error(this._debugPeerName + ": " +
        "No channelId given.");
    return null;
  }
  // If a channel with this label already exists, fail.
  if (channelId in this.channels) {
    trace.error(this._debugPeerName + ": " +
        "This channelId already exists: " + channelId);
    return null;
  }
  // Default to reliable channels.
  if (!options) {
    options = {'reliable': true}
  }
  // Create and setup the new data channel.
  var channel = this.pc.createDataChannel(channelId, options);
  this._setupDataChannel(channel);
  return channel;
}

SimpleDataPeer.prototype.sendMessage = function (channelId, message) {
  if (!(channelId in this.channels)) {
    trace.error(this._debugPeerName + ": " + "No such channel id: " +
        channelId);
    return;
  }
  var channel = this.channels[channelId];
  try {
    channel.send(message);
    trace.log(this._debugPeerName + ": " + "channels[" + channel.label + "]:" +
        "sent: ", message);
  } catch (e) {
    trace.error(this._debugPeerName + ": " + "channels[" + channel.label + "]: " +
        "send failed. channel:", channel, "\nException: ", e.toString());
  }
}

SimpleDataPeer.prototype.closeChannel = function (channelId) {
  this.channels[channelId].close();
  delete this.channels[channelId];
}

SimpleDataPeer.prototype.close = function() {
  for(var channelId in this.channels) {
    this.closeChannel(channelId);
  }
  this.pc.close();
  trace.log(this._debugPeerName + ": " + "Closed peer connection.");
}

// When we get our description, we set it to be our local description and
// send it to the peer.
SimpleDataPeer.prototype._onDescription = function (description) {
  if (this._sendSignalMessage) {
    this.pc.setLocalDescription(description,
        function() {
          this._sendSignalMessage(JSON.stringify({'sdp':description}));
        }.bind(this),
        function (e) {
          trace.error(this._debugPeerName + ": " +
            "setLocalDescription failed:", e);
        }.bind(this));
  } else {
    trace.error(this._debugPeerName + ": " + "_onDescription: _sendSignalMessage is not set, so we did not set the local description. ");
  }
}

//
SimpleDataPeer.prototype._onNegotiationNeeded = function (e) {
  trace.log(this._debugPeerName + ": " + "_onNegotiationNeeded", this.pc, e);
  if(this.pcState != SimpleDataPeerState.DISCONNECTED) {
    // Negotiation messages are falsely requested for new data channels.
    //   https://code.google.com/p/webrtc/issues/detail?id=2431
    // This code is a hack to simply reset the same local and remote
    // description which will trigger the appropriate data channel open event.
    // TODO: fix/remove this when Chrome issue is fixed.
    if (this.pc.localDescription && this.pc.remoteDescription && this.pc.localDescription.type == "offer") {
      this.pc.setLocalDescription(this.pc.localDescription,
          function() {
            trace.log(this._debugPeerName + ": " +
              "Fake setLocalDescription success:");
          }.bind(this),
          function (e) {
            trace.log(this._debugPeerName + ": " +
              "Fake setLocalDescription failed:", e);
          }.bind(this));
      this.pc.setRemoteDescription(this.pc.remoteDescription,
          function() {
            trace.log(this._debugPeerName + ": " +
              "Fake setRemoteDescription success:");
          }.bind(this),
          function (e) {
            trace.log(this._debugPeerName + ": " +
              "Fake setRemoteDescription failed:", e);
          }.bind(this));
    } else if (this.pc.localDescription && this.pc.remoteDescription && this.pc.localDescription.type == "answer") {
      this.pc.setRemoteDescription(this.pc.remoteDescription,
          function() {
            trace.log(this._debugPeerName + ": " +
              "Fake setRemoteDescription success:");
          }.bind(this),
          function (e) {
            trace.log(this._debugPeerName + ": " +
              "Fake setRemoteDescription failed:", e);
          }.bind(this));
      this.pc.setLocalDescription(this.pc.localDescription,
          function() {
            trace.log(this._debugPeerName + ": " +
              "Fake setLocalDescription success:");
          }.bind(this),
          function (e) {
            trace.log(this._debugPeerName + ": " +
              "Fake setLocalDescription failed:", e);
          }.bind(this));
    }
    return;
  }
  this.negotiateConnection();
}

SimpleDataPeer.prototype._onSignalingStateChange = function () {
  trace.log(this._debugPeerName + ": " + "_onSignalingStateChange: ",
      this.pc.signalingState);
  if (this.pc.signalingState == "stable") {
    this.pcState = SimpleDataPeerState.CONNECTED
  }
}

SimpleDataPeer.prototype._onIceCallback = function (event) {
  if (event.candidate) {
    // Send IceCandidate to peer.
    trace.log(this._debugPeerName + ": " + "ice callback with candidate", event);
    if (this._sendSignalMessage) {
      this._sendSignalMessage(JSON.stringify({'candidate': event.candidate}));
    } else {
      trace.warn(this._debugPeerName + ": " + "_onDescription: _sendSignalMessage is not set.");
    }
  }
}

SimpleDataPeer.prototype._onDataChannel = function (event) {
  this._setupDataChannel(event.channel);
}

SimpleDataPeer.prototype._setupDataChannel = function (channel) {
  if(channel.label in this.channels) {
    trace.warn("Channel with label '" + channel.label + "' already exists; closing the old one and creating a new one.");
    this.channels[channel.label].close();
  }
  this.channels[channel.label] = channel;

  if (this._debug) {
    /* // Another way to write the same thing.
    channel.onopen = this._onChannelStateChange.bind(this, channel);
    channel.onclose = this._onChannelStateChange.bind(this, channel);
    channel.onerror = this._onChannelStateChange.bind(this, channel);
    channel.onmessage = this._onMessageCallback.bind(this, channel);
    */
    channel.addEventListener('open',
        this._onChannelStateChange.bind(this, channel));
    channel.addEventListener('close',
        this._onChannelStateChange.bind(this, channel));
    channel.addEventListener('error',
        this._onChannelStateChange.bind(this, channel));
    channel.addEventListener('message',
        this._onMessageCallback.bind(this, channel));
  }
}

SimpleDataPeer.prototype._onChannelStateChange = function (channel) {
  trace.log(this._debugPeerName + ": " + "dataChannel(" + channel.label +
      "): " + "State changed: " + channel.readyState, event);
}

// Channel event handlers
SimpleDataPeer.prototype._onMessageCallback = function (channel, event) {
  trace.log(this._debugPeerName + ": " + "dataChannel(" + channel.label +
      "): " + "Received message event: ", event)
}

SimpleDataPeer.prototype.getChannelIds = function () {
  return Object.keys(this.channels);
}

SimpleDataPeer.prototype.getChannel = function (channelId) {
  return this.channels[channelId];
}

SimpleDataPeer.prototype.removeChannel = function (channelId) {
  delete this.channels[channelId];
}




//-----------------------------------------------------------------------------
// Smart wrapper for a data channels, including real notion of open an queuing
//-----------------------------------------------------------------------------
// Stores state of a datachannel. The issue is that even when a data channel is
// in state open, unless the other end is also open, sent messages may not be
// receieved. To ensure that sent messages are recieved, we send an initial ping
// - pong message and consider the chanel truly open once we get or send a pong
// message.
PingPongMessage =  {
  PING: 'ping',
  PONG : 'pong'
};
SmartDataChannelState =  {
  PENDING : 'pending', // waiting for channel to open.
  PINGED : 'pinged',  // I got a ping (and sent a pong)
  PONGED : 'ponged',  // I never got a ping message, but I got a pong.
  CONNECTED: 'connected',  // Have got both a ping and a pong from the peer.
  CLOSED : 'closed' // channel was closed.
};

function SmartDataChannel(channel, options) {
  if (options) {
    this._debugPeerName = options.debugPeerName;
  } else {
    this._debugPeerName = "";
  }
  this._onPingPongMessageFn = null;
  this.dataChannel = channel;
  this.state = SmartDataChannelState.PENDING;
  this.queue = [];
  //
  channel.addEventListener("open", this._startPingPong.bind(this));
  channel.addEventListener("close", this.close.bind(this));
  channel.addEventListener("error", this._onError.bind(this));

  /* // Another way to write the same thing.
  channel.onopen = this._startPingPong.bind(this);
  channel.onclose = this.close.bind(this);
  channel.onerror = this._onError.bind(this);
  */
}

SmartDataChannel.prototype._startPingPong = function () {
  // We bind _onPingPongMessageFn so that we can remove the event listener
  // later.
  this._onPingPongMessageFn = this._onPingPongMessage.bind(this);
  this.dataChannel.addEventListener("message", this._onPingPongMessageFn);
  /* // Another way to write the same thing.
  this.dataChannel.onmessage = this._onPingPongMessageFn;
  */
  trace.log(this._debugPeerName + ": dataChannel(" + this.dataChannel.label +
      "): Sending PING");
  this.dataChannel.send(PingPongMessage.PING);
}

// This logic is complex. :(  TODO: this should not be needed; when a data
// channel is open, this should guarentee that the message will get to the other
// side. See issue: https://code.google.com/p/webrtc/issues/detail?id=2406&thanks=2406&ts=1379699312
SmartDataChannel.prototype._onPingPongMessage = function (event) {
  trace.log(this._debugPeerName + ": dataChannel(" + this.dataChannel.label +
      "): Message during PingPong startup: ", event);
  if (event.data == PingPongMessage.PING) {
    if (this.state == SmartDataChannelState.PONGED) {
      this._onConnected();
    } else if (this.state == SmartDataChannelState.PENDING) {
      this.dataChannel.send(PingPongMessage.PONG);
      this.state = SmartDataChannelState.PINGED;
    } else {
      trace.log(this._debugPeerName + ": dataChannel(" +
          this.dataChannel.label +
          "): unkown state for message: " + this.state);
    }
  } else if (event.data == PingPongMessage.PONG) {
    if (this.state == SmartDataChannelState.PINGED) {
      this._onConnected();
    } else if (this.state == SmartDataChannelState.PENDING) {
      this.dataChannel.send(PingPongMessage.PONG);
      this._onConnected();
    } else {
      trace.error(this._debugPeerName + ": dataChannel(" +
          this.dataChannel.label +
          "): unkown state for message: " + this.state);
    }
  } else {
    // Sometimes we get messages with a channel id when a channel starts up. I
    // think this is a bug:
    //   https://code.google.com/p/webrtc/issues/detail?id=2439
    // TODO: When that bug is fixed, add a warning here.
  }
}

SmartDataChannel.prototype._onError = function (e) {
  trace.error(this._debugPeerName + ": dataChannel(" + this.dataChannel.label +
        "): error: ", e);
}

SmartDataChannel.prototype._onConnected = function () {
  trace.log(this._debugPeerName + ": dataChannel(" + this.dataChannel.label +
        "): CONNECTED", event);
  this.state = SmartDataChannelState.CONNECTED;
  this.dataChannel.removeEventListener("message", this._onPingPongMessageFn);
  /* // the other way, to debug messages received.
  this.dataChannel.onmessage = function (event) {
    trace.log(this._debugPeerName + ": dataChannel(" + this.dataChannel.label +
        "): _onConnected message event: ", event);
  }.bind(this);
  */
  this._sendQueuedMessages();
}

SmartDataChannel.prototype._sendQueuedMessages = function () {
  var message;
  while(message = this.queue.shift()) {
    this.dataChannel.send(message);
  }
}

SmartDataChannel.prototype.send = function (message) {
  if (this.state == SmartDataChannelState.CONNECTED) {
    this.dataChannel.send(message);
  } else {
    this.queue.push(message);
  }
}

SmartDataChannel.prototype.close = function () {
  if(this.dataChannel.readyState != "closed") {
    this.dataChannel.close();
  }
  this.state == SmartDataChannelState.CLOSED;
}


//-----------------------------------------------------------------------------
// Nicer wrapper for P2P data channels
//-----------------------------------------------------------------------------
// A smart wrapper for data channels that queues messages.
function DataPeer(options) {
  this.options = options;
  this.simplePeer = new SimpleDataPeer(this.options);
  this.ready = false;
  // The SmartChannel wrapper for each dataChannel in simplePeer
  // Invariant: Object.keys(this.simplePeer.channels) ==
  // Object.keys(this.smartChannels)
  this.smartChannels = {};

  this.simplePeer.pc.addEventListener("datachannel",
      this._onNewDataChannel.bind(this));
  /* // Another way
  this.simplePeer.pc.ondatachannel = this._onNewDataChannel.bind(this);
  */
};

DataPeer.prototype.setSendSignalMessage = function (sendSignalMessageFn) {
  this.simplePeer.setSendSignalMessage(sendSignalMessageFn);
}

DataPeer.prototype._onNewDataChannel = function (event) {
  this.smartChannels[event.channel.label] =
      new SmartDataChannel(event.channel, this.options);
}

// If channel doesn't already exist, start a new channel.
DataPeer.prototype.send = function (channelId, message) {
  if(!(channelId in this.smartChannels)) {
    this.newDataChannel(channelId)
  }
  this.smartChannels[channelId].send(message);
}

DataPeer.prototype.newDataChannel = function (channelId) {
  var channel = this.simplePeer.newDataChannel(channelId);
  this.smartChannels[channelId] = new SmartDataChannel(channel, this.options);
}

DataPeer.prototype.getChannelIds = function () {
  return this.simplePeer.getChannelIds();
}

DataPeer.prototype.getChannel = function (channelId) {
  return this.simplePeer.getChannel(channelId);
}

DataPeer.prototype.closeChannel = function (channelId) {
  if(!(channelId in this.simplePeer.channels)) {
    trace.warn(this.options.debugPeerName + ": " + "Trying to close a data channel id (" + channelId + ") that does not exist.");
    return;
  }
  this.smartChannels[channelId].close();
  delete this.smartChannels[channelId];
  this.simplePeer.removeChannel(channelId);
}

DataPeer.prototype.close = function (channelId) {
  for(var channelId in this.smartChannels) {
    this.closeChannel(channelId)
  }
  trace.log(this.options.debugPeerName + ": " + "Closed DataPeer.");
}

DataPeer.prototype.handleSignalMessage = function (message) {
  this.simplePeer.handleSignalMessage(message);
};

</script>
</body></html>
